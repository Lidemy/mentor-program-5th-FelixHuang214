## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫

<s>雜湊與加密最大的差別在於加密只要知道加密的規則，就能將加密後的字串還原成輸入的密碼，而雜湊沒辦法還原成原本的密碼。</s>
雜湊與加密最大的差別在於前者是不可逆的而後者是可逆的，而使用者的密碼應該只有使用者知道，不管是開發者或是管理後台的人員都不該知道這組密碼，因此使用雜湊這種不可逆的方式，將密碼儲存在資料庫，我們只需比對雜揍後的值是否相同即可登入。

## `include`、`require`、`include_once`、`require_once` 的差別

include 與 require 都是引入外部檔案，兩者最大差別是後者「遇到錯誤會立即停止」，前者會繼續執行。另外 include 可以利用條件去判斷是否引入檔案<s>後者則沒辦法</s>。而為了避免同個檔案多次引入而導致錯誤，我們使用 include\_once 及 require\_once。


## 請說明 SQL Injection 的攻擊原理以及防範方法

SQL Injection 是利用改變我們對資料庫的操作的指令，來達成偷取資料或是改變我們資料的行為，例如原本我們需要與資料庫比對帳號及密碼，必須兩者都符合才能登入，我們程式碼可以這樣寫: 

```
$sql = sprint(
  "SELECT * FROM users
    WHERE username='%s' AND password='%s'",
    $username, $password
);
$result = $conn->query($sql);
if ($result->num_rows === 0) {
  //  登入失敗
}
//  登入成功
```
如果攻擊者想登入 ABC123 這位會員的帳號時，他可以這樣輸入

```
$username = ABC123' #
```

這時對資料庫操作的指令就變成

```
SELECT * FROM users WHERE username='ABC123' #' 
AND password=''
```
如此一來他就能透過註解的方式來繞過資料庫對密碼的檢查，來登入該帳號。

那麽該如何解決呢？我們可以使用 prepared statement 來讓 PHP 呼叫資料庫，幫我們做指令的字串拼接，就不會發生上述的情況。

我們將一開始的程式碼改成: 

```
$stmt = $conn->prepare(
  'SELECT * FROM users
    WHERE username=? AND password=?'
);
$stmt->bind_param('ss', $username, $password);
$result = $stmt->execute();
$result = $stmt->get_result();
if ($result->num_rows === 0) {
  //  登入失敗
}
//  登入成功
```
這樣攻擊者就不能利用輸入的帳號來操控我們的資料庫。

##  請說明 XSS 的攻擊原理以及防範方法

XSS 透過我們顯示得資料來操控網頁，例如在留言內容輸入

```
<script>window.location = 'http://haker.html'</script>
```
如此一來只要進到會顯示該內容的網頁時就會被導入至「haker.html」，而這時對方可以將此網頁做的與原始網頁一樣，當你輸入任何資料它都能接收到。

預防方法就是如果要顯示使用者輸入的資料，那麼就必須使用 htmlspectialchars 來對特殊字元做轉換後再顯示出來。

## 請說明 CSRF 的攻擊原理以及防範方法

當我們登入某個網站後，對方會給我們一個驗證身份的 cookie，當我們瀏覽其它網頁時瀏覽器也會帶著這個 cookie，這時攻擊者可以利用此特性偽造該使用者來對使用者登入過的網站進行操作，例如攻擊者知道一個網址可以執行發布文章的動作，而攻擊者在自己的網頁上做了個按鈕放置了該網址，當該使用者點擊此按鈕後，就會在不知情的狀況下發布文章。

防範的方法不是單方面的，而是使用者及開發者接需共同防範，才能有效預防，使用者可以盡量不使用自動登入，且將不常使用的網站做登出。
開發者可以增加操作前的確認畫面，像是登入前需輸入亂數驗證碼，或是用第三方驗證例如手機簡訊等。

### 檢查 Refere

檢查 HTTP 表頭內的 Refere 欄位，裡面會標明請求來源於哪個位置，這時只要確認 Refere 欄位與請求的位址是否位於相同域名，這樣就能擋下從其它網站發來的請求，但這種方法過於依賴瀏覽器，並不能完全規避攻擊。

###Synchronizer Token

伺服器在收到使用者的請求時，給了一組驗證用的 token 夾帶在 HTML 表格中並傳給使用者。在提交表格時，這組 token 會一併提交至伺服器，經比對後才會執行動作，因為此組驗證碼沒有夾帶在 cookie 內，因此外部網站想冒用使用者來向該網站請求時，因為沒有該組 token 因此會無法執行該動作。